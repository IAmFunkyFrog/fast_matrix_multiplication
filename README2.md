# Отчет

ФИО: Трефилов Степан Захарович

### Задание A-09

```
Написать программу вычисления матричного выражения:

C = A*B.

Матрица  A  верхне-треугольная. Хранится в виде одномерного массива по блочным столбцам.
Матрица  B  квадратная. Хранится в виде одномерного массива по блочным столбцам.
```

### Тестовый стенд
На тестовом стенде используется AMD Ryzen следующей модели
```
Architecture:            x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Address sizes:         48 bits physical, 48 bits virtual
  Byte Order:            Little Endian
CPU(s):                  12
  On-line CPU(s) list:   0-11
Vendor ID:               AuthenticAMD
  Model name:            AMD Ryzen 5 7535HS with Radeon Graphics
```

### Описание метода решения задачи
Была написана программа на языке Си для вычисления предложенного выражения.

После написания последовательной версии, была написана более оптимальная последовательная версия (версия 2), которая хранит матрицу A в плоском массиву без лишних нулей (так как матрица верхнетреугольная). Кроме того, умножения в версии 2 производятся блочно.

После версии 2, была написана версия 3, в который кроме того, что матрицы умножаются поблочно, они также поблочно хранятся в памяти.

Также была реализована 4 версия, в которой к версии 2 применяется OpenMP для умножения блоков на разных ядрах процессора.

Программный код доступен по [ссылке](https://github.com/IAmFunkyFrog/fast_matrix_multiplication/tree/main)

### Корректность параллельной версии
Для проверки корректности параллельной версии был написан скрипт <pre>verify.sh</pre>, которые вычисляет требуемую формулу с рандомно заполненными входными данными, и сравнивает ответы с самым результатом самого простого алгоритма. Сравнение результатов идет с точностью до 6 знака после запятой:

Пример вывода скрипта:
```
Verification of algorithm 2
Test 0 passed: 0
Test 1 passed: 0
Test 2 passed: 0
Test 3 passed: 0
Test 4 passed: 0
Test 5 passed: 0
Test 6 passed: 0
Test 7 passed: 0
Test 8 passed: 0
Test 9 passed: 0
Test 10 passed: 0
Verification of algorithm 3
Test 0 passed: 0
Test 1 passed: 0
Test 2 passed: 0
Test 3 passed: 0
Test 4 passed: 0
Test 5 passed: 0
Test 6 passed: 0
Test 7 passed: 0
Test 8 passed: 0
Test 9 passed: 0
Test 10 passed: 0
Verification of algorithm 4
Test 0 passed: 0
Test 1 passed: 0
Test 2 passed: 0
Test 3 passed: 0
Test 4 passed: 0
Test 5 passed: 0
Test 6 passed: 0
Test 7 passed: 0
Test 8 passed: 0
Test 9 passed: 0
Test 10 passed: 0
```

### Результаты измерений

Каждый результат по времени исполнения некоторой конфигурации программы был получен как среднее 10 запусков. При необходимости можно сделать больше запусков, однако стандартное отклонение довольно низкое для десяти запусков, то есть результаты довольно стабильны.

Результаты последовательной версии программы (самый простой алгоритм 1):

| Размерность матриц | Среднее время выполнения, сек       | Дисперсия времени выполнения      |
|------|-----------|----------|
| 1536 | 11.091400 | 0.203771 |
| 1792 | 15.166900 | 0.030223 |
| 2048 | 61.322300 | 0.128503 |
| 2304 | 38.872600 | 0.687141 |
| 2560 | 60.493800 | 0.033264 |


Результаты последовательной версии 2 (более оптимальное хранение матрицы A в виде плоского массива и блочное умножение):

| Размерность матриц | Среднее время выполнения, сек       | Дисперсия времени выполнения      |
|------|----------|----------|
| 1536 |  4.762700 | 0.002830 |
| 1792 |  4.173200 | 0.000081 |
| 2048 | 17.269800 | 0.053528 |
| 2304 |  8.963500 | 0.002691 |
| 2560 | 21.684400 | 0.000563 |

Результаты последовательной версии 3 (хранение матриц A и B поблочно, умножение поблочно):

| Размерность матриц | Среднее время выполнения, сек       | Дисперсия времени выполнения      |
|------|----------|----------|
| 1536 | 1.574900 | 0.000127 |
| 1792 | 2.489300 | 0.000155 |
| 2048 | 3.719700 | 0.000430 |
| 2304 | 5.269600 | 0.000333 |
| 2560 | 7.236400 | 0.000259 |

Результаты параллельной версии:

| Размерность матриц | Среднее время выполнения, сек       | Дисперсия времени выполнения      |
|------|----------|----------|
| 1536 | 0.540400 | 0.000188 |
| 1792 | 0.718900 | 0.000056 |
| 2048 | 4.269900 | 0.010939 |
| 2304 | 1.530100 | 0.000277 |
| 2560 | 2.429400 | 0.000019 |

##### Вывод

Как можно увидеть, блочное умножение в комбинации с оптимальным хранением матрицы А в памяти позволяет получить огромное ускорение по сравнению с наивным алгоритмом. Кроме того, если матрицы поблочно не только умножать, но и хранить, улучшая тем самым локальность памяти, можно ускорить алгоритм еще больше. Даже без применения векторных расширений современных процессоров, и используя 1 ядро процессора, удалось получить ускорение порядка 9 раз.