# Отчет

ФИО: Трефилов Степан Захарович

### Задание A-09

```
Написать программу вычисления матричного выражения:

C = A*B.

Матрица  A  верхне-треугольная. Хранится в виде одномерного массива по блочным столбцам.
Матрица  B  квадратная. Хранится в виде одномерного массива по блочным столбцам.
```

### Тестовый стенд
На тестовом стенде используется AMD Ryzen следующей модели
```
Architecture:            x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Address sizes:         48 bits physical, 48 bits virtual
  Byte Order:            Little Endian
CPU(s):                  12
  On-line CPU(s) list:   0-11
Vendor ID:               AuthenticAMD
  Model name:            AMD Ryzen 5 7535HS with Radeon Graphics
```

### Описание метода решения задачи
Было написано 4 программы на языке Си для вычисления предложенного выражения.

##### Алгоритм 1 (наивный алгоритм умножения матриц)

Первым был написан самый простой "наивный" алгоритм умножения матриц. В нем матрицы, храняющиеся по столбцам, умножаются с помощью 3 циклов самым простым образом.

##### Алгоритм 2 (хранение верхнетреугольной матрицы в массиве + поблочное умножение)

Далее в качестве оптимизации 1 алгоритма было сделано 2 действия:
1. Теперь верхнетреугольная матрица хранится не в виде матрицы с лишними нулями, а в виде плоского массива. Для получения элемента M[i, j] матрицы M из плоского массива M_flat применяется следующая формула:
M[i, j] = M_flat[j * (j + 1) / 2 + i]

2. Вместо наивного умножения, применяется поблочное умножения. Данная оптимизация позволяет более эффективно использовать кеш процессора.

##### Алгоритм 3 (хранение матриц поблочно + поблочное умножение)

Далее в качестве оптимизации 2 алгоритма хранение обеих матриц было сделано поблочно. То есть, каждая из матриц A и B хранится в памяти как набор блоков, и каждый блок представляет собой обычную маленькую матрицу, храняющуюся по столбцам. Данная оптимизации позволяет еще лучше использовать процессорный кеш, так как данные каждого блока хранятся более локально и процессор может произвести prefetch блоков в кеш.

##### Алгоритм 4 (OpenMP на алгоритме 2)

Далее было решено распараллелить алгоритм 2 с помощью OpenMP. Умножения каждого отдельного блока была выделено в отдельную OMP task.

Программный код доступен по [ссылке](https://github.com/IAmFunkyFrog/fast_matrix_multiplication/tree/main)

### Корректность параллельной версии
Для проверки корректности параллельной версии был написан скрипт <pre>verify.sh</pre>, которые вычисляет требуемую формулу с рандомно заполненными входными данными, и сравнивает ответы с самым результатом самого простого алгоритма. Сравнение результатов идет с точностью до 6 знака после запятой:

Пример вывода скрипта:
```
Verification of algorithm 2
Test 0 passed: 0
Test 1 passed: 0
Test 2 passed: 0
Test 3 passed: 0
Test 4 passed: 0
Test 5 passed: 0
Test 6 passed: 0
Test 7 passed: 0\
Test 8 passed: 0
Test 9 passed: 0
Test 10 passed: 0
...
```

### Результаты измерений

Каждый результат по времени исполнения некоторой конфигурации программы был получен как среднее 10 запусков. При необходимости можно сделать больше запусков, однако стандартное отклонение довольно низкое для десяти запусков (менее 1 секунды в худшем случае).

На тестовой конфигурации наивный алгоритм умножения матриц 2880 на 2880 занимает порядка 73 секунд.

Результаты запусков (время приведено в секундах):
| Размер блока | Алгоритм 2 (хранение верхнетреугольной матрицы в массиве + поблочное умножение) | Алгоритм 3 (поблочное хранение + поблочное умножение) | OMP для алгоритма 2 |
|--------------|---------------------------------------------------------------------------------|-------------------------------------------------------|---------------------|
|           16 |                                                                          15,64 |                                                11,45 |                3,72 |
|           32 |                                                                          13,68 |                                             10,37 |                2,75 |
|           80 |                                                                          15,14 |                                             10,14 |                2,39 |
|          120 |                                                                       15,36 |                                             10,23 |                2,19 |
|          240 |                                                                       15,07 |                                             11,28 |                2,31 |

Неудивительно, наилучший результат показал алгоритм, использующий OMP, так как он позволяет использовать более 1 ядра процессора.

Тем не менее, интересно, что даже без применения технологий распараллеливания кода, можно получить ускорение порядка 5-7 раз.

По табличке не трудно заметить, что оптимальный размер блока лежит где то между 80 и 120. Это не случайно, так как кеш L1 процессора из тестового стенда имеет 192 KiB, то есть, если мы хотим эффективно умножать матрицы поблочно, нужно, чтобы один блок матрицы занимал порядка 64 KiB. При размере блока 80, получается, что один блок матрицы занимает 80 * 80 * 8 = 51200 байт, что довольно близко к 64 KiB. Аналогично, при размере блока 120, один блок занимает 120 * 120 * 8 = 115200, что больше, чем 64 KiB, но относительно не сильно. При размере блока 240, блок занимает ~460000 байт, что больше размера L1 кеша.

##### Вывод

Как можно увидеть, блочное умножение в комбинации с оптимальным хранением матрицы А в памяти позволяет получить огромное ускорение по сравнению с наивным алгоритмом. Кроме того, если матрицы поблочно не только умножать, но и хранить, улучшая тем самым локальность памяти, можно ускорить алгоритм еще больше. Даже без применения векторных расширений современных процессоров, и используя 1 ядро процессора, удалось получить ускорение порядка 7 раз.